# Инструкция по аннотированию инструментов (GroundingDINO → SAM-2 → DINOv3)

## Обзор
Скрипт `annotate_gdino_sam2_dinov3_hf.py` выполняет полуавтоматическую разметку инструментов на фото:
- GroundingDINO находит кандидаты (bbox) по текстовому запросу.
- SAM‑2 уточняет маску объекта внутри каждого bbox.
- DINOv3 сравнивает вырез с эталонами и присваивает класс.
- Классы перераспределяются так, чтобы на одном изображении классы не повторялись (уникальность).
- По желанию сохраняются визуализации (bbox и маски).
- Результаты сохраняются в `predictions.json` с RLE-масками.

## Папки и файлы
- Изображения: `IMAGES_DIR`
- Галерея эталонов: `GALLERY_DIR` (PNG/JPG)
- Папка эксперимента: `BASE_DIR`
- Основной скрипт: `annotate_gdino_sam2_dinov3_hf.py`
- Результаты:
  - `predictions.json` — разметка (bbox, класс, маска в RLE)
  - `timings.csv` — времена стадий
  - `debug/` — отладочные кропы, маски и сравнения
  - `*_ann.jpg`, `*_ann_recalculated.jpg`, `*_ann_with_masks.jpg` — визуализации

## Запуск аннотирования
1) Настройте пути и параметры в начале `annotate_gdino_sam2_dinov3_hf.py`:
- `IMAGES_DIR`, `GALLERY_DIR`, `BASE_DIR`, `NUM_IMAGES`
- Модель DINOv3: `TIMM_DINOV3_ID`
- GroundingDINO: `GROUNDING_DINO_MODEL`, `GROUNDING_PROMPT`, `BOX_THR`, `TEXT_THR`
- SAM-2: `SAM2_CFG`, `SAM2_CKPT`
- Флаги:
  - `SAVE_VIS`: сохранять ли визуализации
  - `JSON_SAVE_TQDM`: показывать прогресс при сохранении JSON
  - `JSON_SAVE_ASYNC`: сохранять JSON асинхронно

2) Запустите:
```bash
python3 /home/ubuntu/diabert/dataset/predrazmetka_dashi/annotate_gdino_sam2_dinov3_hf.py
```

После завершения результаты будут в `BASE_DIR`.

## Формат predictions.json
Это список записей по изображениям:
```json
{
  "image": "DSCN4946.JPG",
  "detections": [
    {
      "bbox_xyxy": [x1, y1, x2, y2],
      "class": "Имя класса",
      "score_metric": 0.73,
      "score_vlm": 0.65,
      "vlm_class": "tool",
      "ranked": [{"name": "Класс1", "score": 0.73}, ...],
      "mask_rle": {"size": [H, W], "counts": [n0, n1, ...], "order": "row-major"}
    }
  ]
}
```
- `mask_rle` — бинарная маска, закодированная RLE (атрибуты `size` и `counts`).
- Если `score_metric` не число, он будет `null`.

## Визуализация из predictions.json
Отдельный скрипт `visualize_predictions.py` строит визуализации по готовому `predictions.json`:
- Настройте пути внутри файла (`PREDICTIONS_JSON`, `IMAGES_DIR`, `OUT_DIR`).
- Запустите:
```bash
python3 /home/ubuntu/diabert/dataset/predrazmetka_dashi/visualize_predictions.py
```
- На выходе вы получите изображения в `OUT_DIR`, аналогичные `*_ann_with_masks.jpg`.

## Производительность
- Маски рисуются в один общий RGBA-оверлей, что значительно ускоряет визуализацию.
- DINOv3 в 2-GPU режиме переведён на float32 без autocast/fp16 для стабильности.
- Сохранение JSON может выполняться асинхронно (`JSON_SAVE_ASYNC=True`).
- Прогресс при сохранении JSON можно включить флагом `JSON_SAVE_TQDM=True`.

## Отладка
- Папка `debug/` содержит для каждого детекта: кроп, бинарную маску, similarities.json и копии эталонов.
- `timings.csv` показывает времена: детекция, SAM‑2, эмбеддинг/сопоставление и суммарное время.

## Частые вопросы
- Маски в JSON слишком большие? RLE компактнее массива, при необходимости можно отключить сохранение `mask_rle` в коде.
- Нужны только маски, без bbox? Можно взять `mask_rle`, игнорируя `bbox_xyxy`.
- Нестабильность при больших моделях? В 2-GPU режиме используется float32 и отключен autocast/fp16.
